
const generateBtn = document.querySelector("#generateBtn");
const textTextarea = document.querySelector("#textTextarea");
const errorDiv = document.querySelector("#errorDiv");
const wordOutput = document.querySelector("#wordOutput");
let errors = [];

let data = {};

let words = [];

let output = "";



generateBtn.addEventListener("click", () => {
  textParse();
  generate();
})

textTextarea.addEventListener("input", () => {
  removeErrors();
})

function showError(a) {
  errors.push(a);
  errorDiv.innerHTML = "";
  for (let i = 0; i < errors.length; i++) {
    errorDiv.innerHTML += `<span class="errorSpan" style="color: var(--colorDarkest);"><span style="color: var(--colorErrorPrimary);" class="material-icons">error</span> ${errors[i]}</span>`;
  }
  

}

function removeErrors() {
  errors = [];
  errorDiv.innerHTML = "";

}

function textParse() {
  data = {};
  let text = textTextarea.value;
  if (text.length === 0) {
    showError("Add text for processing to work.")
    return;
  }
  text = text
    .replace(/\s+/g, ' ')
    .trim();
  // console.log(text);
  const arr = text.split(' ');
  for (let i = 0; i < arr.length; i++) {
    // filling the data object.
    if (!arr[i + 1]) {
      continue;
    }
    const word = arr[i];
    
    /*
    if (word.length < 4) {
      // must be at least 4 letters long.
      continue;
    }
    */
    
    if (data[word]) {
      data[word].push(arr[i + 1]);
    } else {
      data[word] = [arr[i + 1]];
    }
    
  }
  /*
  if (Object.keys(data).length == 0) {
    showError("Invalid text. Only words with 4 or more letters count.")
  }
  */
  console.log(data);
}

function generate() {
  
  output = "Alice was"; // testing one.
  words = [];
  wordOutput.innerHTML = "";
  const wordGroups = Object.keys(data);
  for (let j = 0; j < 100; j++) {
    // let word = wordGroups[Math.floor(Math.random() * wordGroups.length)];
    const possibleGroups = []
    /*
    for (let k = 0; k < wordGroups.length; k++) {
      // console.log(wordGroups[k].split(" ")[0]);
      // console.log(output.split(' ')[output.split(' ').length - 1]);
      console.log(output.split(' ')[output.split(' ').length - 1]);
      if (wordGroups[k] == output.split(' ')[output.split(' ').length - 1]) {
        console.log("inthere");
        possibleGroups.push(wordGroups[k]);
      }
    }
    */
    // console.log("possible:", possibleGroups);
    if (1 > 0) {
      const word = data[output.split(' ')[output.split(' ').length - 1]];
      output = output + " " + word[Math.floor(Math.random() * word.length)];
      /*
      let total = 0;
      for (let k = 0; k < possibleGroups.length; k++) {
        // console.log(possibleGroups[k], data[possibleGroups[k]]);
        total += data[possibleGroups[k]];
      }
      let accum = 0;
      let rand = Math.random() * total;
      for (let k = 0; k < possibleGroups.length; k++) {
        // possibleGroups[k], data[possibleGroups[k]]
        if (rand <= data[possibleGroups[k]] + accum) {
          output = output + " " + possibleGroups[k].split(" ")[1];
          break;
        }
        accum += data[possibleGroups[k]];
      }
      */
    } else {
      // console.log("No possiblities: ", word);
      output = output + " was"; // make it random based on whether the last was a vowel or not.
    }
  }
  console.log(output);
  wordOutput.innerHTML += `${output}`;
  
}



/*
What if we were to use a Markov chain for generating sentences 
for the GS1 or GS2 systems to be in my game and the reason this 
could work is basically we define a whole bunch of sentences we 
just put them in A you know a massive paragraph and these are 
basically different sentence structures and then what we do is
we run a Markov chain for one sentence or maybe we run it for
an entire paragraph and then use that paragraph as just a 
paragraph or we chain multiple Markov chain sentences 
together and get a paragraph and basically that's your
first pass then what you do is you would take the sentence
generated by the Markov chain and you would substitute it 
with more specific things to that environment so say you
have a Markov chain paragraph input of just describing 
the surroundings and then your second pass would be making it specific
to the surroundings you're in so if you're in a force it would change
it to be describing a forest it would still use the initial Markov 
chain generation to do so and then your 3rd pass would basically be the
synonym system so it would substitute words for their synonyms

*/